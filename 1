Вот адаптированная версия вашего кода, подготовленная для запуска в Jupyter Notebook с ячейками, разделяющими этапы генерации данных, подключения к базам данных и выполнения задач IoT. Код включает необходимые импорты, функции и инструкции для пошагового выполнения без использования команды !pip внутри, так как лучше устанавливать библиотеки отдельно перед запуском.

***

```python
# Ячейка 1: Импорт библиотек и базовые настройки
import pandas as pd
import numpy as np
from pymongo import MongoClient
import psycopg2
from sqlalchemy import create_engine
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
import time
import warnings
warnings.filterwarnings('ignore')

plt.style.use('seaborn-v0_8')
sns.set_palette("husl")

# Функции проверки подключения
def check_mongo_connection(client):
    try:
        client.server_info()
        print("✅ Успешное подключение к MongoDB")
        return True
    except Exception as e:
        print(f"❌ Ошибка подключения к MongoDB: {e}")
        return False

def check_postgres_connection(conn_params):
    try:
        conn = psycopg2.connect(**conn_params)
        print("✅ Успешное подключение к PostgreSQL")
        return conn
    except Exception as e:
        print(f"❌ Ошибка подключения к PostgreSQL: {e}")
        return None

def measure_time(func, *args, **kwargs):
    start_time = time.time()
    result = func(*args, **kwargs)
    end_time = time.time()
    return result, end_time - start_time
```

***

```python
# Ячейка 2: Генерация тестовых данных
np.random.seed(42)

n_users = 10000
n_products = 1000
n_views = 100000

# Генерация пользователей
users_data = [{
    'id': i,
    'name': f"User_{i:05d}",
    'email': f"user{i}@example.com",
    'age': np.random.randint(18, 65)
} for i in range(n_users)]

# Генерация товаров
categories = ['Electronics', 'Clothing', 'Books', 'Home', 'Sports', 'Beauty', 'Toys', 'Automotive']
products_data = [{
    'id': i,
    'name': f"Product_{i:04d}",
    'category': np.random.choice(categories),
    'price': round(np.random.uniform(10, 1000), 2)
} for i in range(n_products)]

# Генерация просмотров с учетом популярности товаров
start_date = datetime(2023, 1, 1)
product_popularity = np.random.pareto(1.5, n_products)
product_popularity /= product_popularity.sum()

views_data = [{
    'user_id': np.random.randint(0, n_users),
    'product_id': np.random.choice(n_products, p=product_popularity),
    'timestamp': start_date + timedelta(days=np.random.randint(0, 365))
} for _ in range(n_views)]

# Создание DataFrame
users_df = pd.DataFrame(users_data)
products_df = pd.DataFrame(products_data)
views_df = pd.DataFrame(views_data)

# Вывод информации по данным
print(f"Users: {len(users_df):,}, Products: {len(products_df):,}, Views: {len(views_df):,}")
print(users_df.head())
print(products_df.head())
print(views_df.head())
```

***

```python
# Ячейка 3: Сохранение данных в CSV (если нужно)
users_df.to_csv('users.csv', index=False)
products_df.to_csv('products.csv', index=False)
views_df.to_csv('views.csv', index=False)
print("✅ Данные сохранены в users.csv, products.csv, views.csv")
```

***

```python
# Ячейка 4: Подключение к MongoDB и загрузка данных
try:
    mongo_client = MongoClient('mongodb://mongouser:mongopass@mongodb:27017/')
    if not check_mongo_connection(mongo_client):
        mongo_client = MongoClient('mongodb://mongouser:mongopass@localhost:27017/')
        check_mongo_connection(mongo_client)
except Exception as e:
    print(f"❌ Ошибка подключения к MongoDB: {e}")
    mongo_client = None

if mongo_client:
    mongo_db = mongo_client['studmongo']
    mongo_db.users.drop()
    mongo_db.products.drop()
    mongo_db.views.drop()
    
    mongo_db.users.insert_many(users_df.to_dict('records'))
    mongo_db.products.insert_many(products_df.to_dict('records'))
    mongo_db.views.insert_many(views_df.to_dict('records'))
    
    mongo_db.users.create_index("id")
    mongo_db.products.create_index("id")
    mongo_db.views.create_index("user_id")
    mongo_db.views.create_index("product_id")
    mongo_db.views.create_index("timestamp")
    print("✅ Данные загружены и индексы созданы в MongoDB")
else:
    print("❌ Пропуск MongoDB из-за ошибки подключения")
```

***

```python
# Ячейка 5: Подключение к PostgreSQL и загрузка данных
pg_params = {
    "dbname": "studpg",
    "user": "postgres",
    "password": "changeme",
    "host": "postgresql",
    "port": "5432"
}

pg_conn = check_postgres_connection(pg_params)

if pg_conn:
    cur = pg_conn.cursor()
    cur.execute("DROP TABLE IF EXISTS views CASCADE")
    cur.execute("DROP TABLE IF EXISTS products CASCADE")
    cur.execute("DROP TABLE IF EXISTS users CASCADE")
    
    cur.execute("""
        CREATE TABLE users (
            id INTEGER PRIMARY KEY,
            name VARCHAR(100),
            email VARCHAR(100),
            age INTEGER
        )
    """)
    
    cur.execute("""
        CREATE TABLE products (
            id INTEGER PRIMARY KEY,
            name VARCHAR(100),
            category VARCHAR(50),
            price DECIMAL(10,2)
        )
    """)
    
    cur.execute("""
        CREATE TABLE views (
            id SERIAL PRIMARY KEY,
            user_id INTEGER REFERENCES users(id),
            product_id INTEGER REFERENCES products(id),
            timestamp TIMESTAMP
        )
    """)
    
    cur.execute("CREATE INDEX idx_views_user_id ON views(user_id)")
    cur.execute("CREATE INDEX idx_views_product_id ON views(product_id)")
    cur.execute("CREATE INDEX idx_views_timestamp ON views(timestamp)")
    pg_conn.commit()
    
    # Загрузка данных
    for _, row in users_df.iterrows():
        cur.execute("INSERT INTO users (id, name, email, age) VALUES (%s, %s, %s, %s)",
                    (row['id'], row['name'], row['email'], row['age']))
    for _, row in products_df.iterrows():
        cur.execute("INSERT INTO products (id, name, category, price) VALUES (%s, %s, %s, %s)",
                    (row['id'], row['name'], row['category'], row['price']))
    for _, row in views_df.iterrows():
        cur.execute("INSERT INTO views (user_id, product_id, timestamp) VALUES (%s, %s, %s)",
                    (row['user_id'], row['product_id'], row['timestamp']))
    pg_conn.commit()
    
    print(f"✅ Данные успешно загружены в PostgreSQL")
    cur.close()
    pg_conn.close()
else:
    print("❌ Пропуск PostgreSQL из-за ошибки подключения")
```

***

```python
# Ячейка 6: Задания для IoT в PostgreSQL и MongoDB

# Построение таблицы sensor_data в PostgreSQL и запрос максимальной температуры
pg_conn = check_postgres_connection(pg_params)
if pg_conn:
    cur = pg_conn.cursor()
    # Создаем таблицу
    cur.execute("DROP TABLE IF EXISTS sensor_data CASCADE")
    cur.execute("""
        CREATE TABLE sensor_data (
            sensor_id INTEGER,
            temperature FLOAT,
            timestamp TIMESTAMP
        )
    """)
    # Пример вставки тестовых данных - можно добавить свои
    # cur.execute("INSERT INTO sensor_data (sensor_id, temperature, timestamp) VALUES (1, 23.5, NOW())")
    pg_conn.commit()
    
    # Запрос максимальной температуры по каждому сенсору
    cur.execute("""
        SELECT sensor_id, MAX(temperature) as max_temp
        FROM sensor_data
        GROUP BY sensor_id
    """)
    max_temps = cur.fetchall()
    print("Максимальная температура по сенсорам (PostgreSQL):")
    for sensor_id, temp in max_temps:
        print(f"Sensor {sensor_id}: {temp}")
        
    cur.close()
    pg_conn.close()
else:
    print("❌ Пропуск задания PostgreSQL из-за ошибки подключения")

# Задание MongoDB: агрегационный запрос для максимальной температуры по сенсорам
if mongo_client:
    mongo_db = mongo_client['studmongo']
    sensor_collection = mongo_db['sensor_data']
    
    # Пример данных для sensor_data (если нужно, вставьте свои)
    # sensor_collection.insert_many([
    #     {"sensor_id": 1, "temperature": 23.5, "timestamp": datetime.now()},
    #     {"sensor_id": 1, "temperature": 25.1, "timestamp": datetime.now()},
    #     {"sensor_id": 2, "temperature": 19.8, "timestamp": datetime.now()}
    # ])
    
    pipeline = [
        {"$group": {"_id": "$sensor_id", "max_temp": {"$max": "$temperature"}}}
    ]
    results = list(sensor_collection.aggregate(pipeline))
    
    print("Максимальная температура по сенсорам (MongoDB):")
    for res in results:
        print(f"Sensor {res['_id']}: {res['max_temp']}")
else:
    print("❌ Пропуск задания MongoDB из-за ошибки подключения")
```

***

```python
# Ячейка 7: Анализ производительности (пример замера времени выполнения агрегатов)
# Здесь можете подставить реальные замеры функций для PostgreSQL и MongoDB
# Примерно так:

def query_postgres_max_temp():
    conn = psycopg2.connect(**pg_params)
    cur = conn.cursor()
    cur.execute("SELECT sensor_id, MAX(temperature) FROM sensor_data GROUP BY sensor_id")
    results = cur.fetchall()
    cur.close()
    conn.close()
    return results

def query_mongo_max_temp():
    pipeline = [
        {"$group": {"_id": "$sensor_id", "max_temp": {"$max": "$temperature"}}}
    ]
    results = list(mongo_db['sensor_data'].aggregate(pipeline))
    return results

if pg_conn and mongo_client:
    pg_result, pg_time = measure_time(query_postgres_max_temp)
    mongo_result, mongo_time = measure_time(query_mongo_max_temp)
    print(f"PostgreSQL max temp query time: {pg_time:.4f} sec")
    print(f"MongoDB max temp query time: {mongo_time:.4f} sec")
else:
    print("❌ Пропуск анализа производительности из-за отсутствия подключений к БД")
```

***

Этот набор ячеек можно запускать поочередно в Jupyter Notebook. Он подходит для создания, загрузки и аналитики больших данных о продажах, а также выполнения IoT-заданий в PostgreSQL и MongoDB с замерами производительности. Если потребуется — можно добавить дополнительные визуализации и расширения анализа.
