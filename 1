Для вашего задания по Интернету вещей (IoT) с тестовой генерацией данных, запросами в PostgreSQL и MongoDB, а также анализом в Jupyter, вот как можно переделать всё под конкретные задачи:

***

### 1. Функция генерации данных IoT для sensor_data

Нужно генерировать записи с полями sensor_id, temperature и timestamp:

```python
import random
from datetime import datetime, timedelta

def generate_iot_data(n_records):
    iot_data = []
    for _ in range(n_records):
        data = {
            "sensor_id": f"sensor_{random.randint(1, 100)}",  # генерация sensor_id (например, 1-100)
            "temperature": round(random.uniform(-10, 40), 1),  # температура с одним знаком после запятой
            "timestamp": datetime.now() - timedelta(minutes=random.randint(0, 60*24*30))  # случайное время в прошлом месяце
        }
        iot_data.append(data)
    return iot_data
```

***

### 2. Создание таблицы и запрос в PostgreSQL

```sql
CREATE TABLE sensor_data (
    sensor_id VARCHAR(50),
    temperature FLOAT,
    timestamp TIMESTAMP
);

-- Запрос максимальной температуры каждого сенсора за все время
SELECT sensor_id, MAX(temperature) AS max_temperature
FROM sensor_data
GROUP BY sensor_id;
```

***

### 3. Создание коллекции и агрегация в MongoDB

Структура документа в коллекции `sensor_data`:

```json
{
  "sensor_id": "sensor_1",
  "temperature": 23.5,
  "timestamp": ISODate("2025-11-12T10:14:00Z")
}
```

Агрегационный запрос MongoDB для максимальной температуры по каждому сенсору:

```js
db.sensor_data.aggregate([
  {
    $group: {
      _id: "$sensor_id",
      max_temperature: { $max: "$temperature" }
    }
  }
])
```

***

### 4. Анализ производительности в Jupyter Notebook (псевдокод)

```python
import psycopg2
import pymongo
import time

# Подключение к PostgreSQL
conn_pg = psycopg2.connect(dbname="studpg", user="student", password="Stud2024!!!", host="localhost")
cur = conn_pg.cursor()

# Подключение к MongoDB
from pymongo import MongoClient
client = MongoClient("mongodb://mongouser:mongopass@localhost:27017/")
db_mongo = client.studmongo
collection = db_mongo.sensor_data

# Измерение времени PostgreSQL
start_pg = time.time()
cur.execute("""
    SELECT sensor_id, MAX(temperature)
    FROM sensor_data
    GROUP BY sensor_id;
""")
result_pg = cur.fetchall()
end_pg = time.time()

# Измерение времени MongoDB
start_mongo = time.time()
pipeline = [
    {"$group": {"_id": "$sensor_id", "max_temperature": {"$max": "$temperature"}}}
]
result_mongo = list(collection.aggregate(pipeline))
end_mongo = time.time()

print(f"PostgreSQL query time: {end_pg - start_pg} seconds")
print(f"MongoDB aggregation time: {end_mongo - start_mongo} seconds")
```

***

### Итог

- Функция генерации iot-данных создана с полями sensor_id, temperature, timestamp.
- Создана таблица sensor_data в PostgreSQL с SQL-запросом для максимальной температуры по каждому сенсору.
- Аналогичный агрегационный запрос для MongoDB.
- Python-код в Jupyter позволяет сравнить скорость выполнения запросов в обеих СУБД.

Если нужно, могу помочь с полным кодом для загрузки данных в базы и запуском примеров. Это полностью соответствует вашей задаче по IoT и сравнению реляционного и NoSQL подходов.











Вот полный пример кода для каждого этапа вашего задания: генерация данных, загрузка в PostgreSQL и MongoDB, выполнение запросов для поиска максимальной температуры и измерение их времени в Jupyter Notebook.

***

### 1. Генерация данных IoT

```python
import random
from datetime import datetime, timedelta

def generate_iot_data(n_records):
    iot_data = []
    for _ in range(n_records):
        data = {
            "sensor_id": f"sensor_{random.randint(1, 100)}",
            "temperature": round(random.uniform(-10, 40), 1),
            "timestamp": datetime.now() - timedelta(minutes=random.randint(0, 60*24*30))
        }
        iot_data.append(data)
    return iot_data
```

***

### 2. Работа с PostgreSQL: создание таблицы, загрузка данных и запрос

```python
import psycopg2
from psycopg2.extras import execute_values

# Подключение к PostgreSQL
conn_pg = psycopg2.connect(dbname="studpg", user="student", password="Stud2024!!!", host="localhost")
cur = conn_pg.cursor()

# Создание таблицы sensor_data
cur.execute("""
CREATE TABLE IF NOT EXISTS sensor_data (
    sensor_id VARCHAR(50),
    temperature FLOAT,
    timestamp TIMESTAMP
);
""")
conn_pg.commit()

# Функция для вставки данных
def insert_data_pg(data):
    tuples = [(d['sensor_id'], d['temperature'], d['timestamp']) for d in data]
    sql = "INSERT INTO sensor_data (sensor_id, temperature, timestamp) VALUES %s"
    execute_values(cur, sql, tuples)
    conn_pg.commit()

# Выполнение запроса максимальной температуры для каждого сенсора
def query_max_temperature_pg():
    cur.execute("""
    SELECT sensor_id, MAX(temperature) AS max_temperature
    FROM sensor_data
    GROUP BY sensor_id;
    """)
    return cur.fetchall()
```

***

### 3. Работа с MongoDB: загрузка данных и агрегация

```python
from pymongo import MongoClient

# Подключение к MongoDB
client = MongoClient("mongodb://mongouser:mongopass@localhost:27017/")
db_mongo = client.studmongo
collection = db_mongo.sensor_data

# Функция для вставки данных
def insert_data_mongo(data):
    # Преобразуем datetime в ISO формат
    for d in data:
        d['timestamp'] = d['timestamp']
    collection.insert_many(data)

# Агрегационный запрос на поиск максимальной температуры по каждому сенсору
def query_max_temperature_mongo():
    pipeline = [
        {"$group": {"_id": "$sensor_id", "max_temperature": {"$max": "$temperature"}}}
    ]
    return list(collection.aggregate(pipeline))
```

***

### 4. Полный пример в Jupyter Notebook: генерация, загрузка, запрос и сравнение времени

```python
import time

# Генерация данных
n_records = 10000  # количество записей
data = generate_iot_data(n_records)

# Вставка данных в PostgreSQL
insert_data_pg(data)

# Вставка данных в MongoDB
insert_data_mongo(data)

# Измерение времени для PostgreSQL
start_pg = time.time()
result_pg = query_max_temperature_pg()
end_pg = time.time()

# Измерение времени для MongoDB
start_mongo = time.time()
result_mongo = query_max_temperature_mongo()
end_mongo = time.time()

print(f"PostgreSQL query time: {end_pg - start_pg:.4f} seconds")
print(f"MongoDB aggregation time: {end_mongo - start_mongo:.4f} seconds")

# Пример вывода первых 5 результатов
print("PostgreSQL results (top 5):", result_pg[:5])
print("MongoDB results (top 5):", result_mongo[:5])
```

***

Этот полный кодчик позволяет:

- Сгенерировать тестовые IoT данные с необходимыми полями.
- Создать и заполнить таблицу в PostgreSQL и коллекцию в MongoDB.
- Выполнить запросы для поиска максимальной температуры по сенсорам.
- Измерить и сравнить производительность этих запросов.

Если нужно, могу помочь с настройкой окружения или подготовкой Docker для запуска этих баз.
